from __future__ import division
import sys
import ROOT
import root_numpy as rnpy
import pandas as pd
import numpy as np

def main(argv):

    batch_size_jets = 1200
    batch_size_tracks = 5200
  
    print("importing jet list")
    # read in new chunk of jet and track data
    d1 = pd.DataFrame(rnpy.root2array(argv[0], treename = "tagVars/ttree", start = 0, stop = batch_size_jets))
    
    print("importing tracks list")
    d2 = pd.DataFrame(rnpy.root2array(argv[0], treename = "tagVars/ttree_track", start = 0, stop = batch_size_tracks))
    
    # figure out where the next chunk should start so that we don't count any jets multiple times
    last_tracks = (int)(d2.tail(1)['Track_jetIndex'].iloc[0]-1)
    last_jet = (int)(d1.tail(1)['Jet_jetIndex'].iloc[0]-1)
    
    # find the latest jet index thatis fully contained in this chunk
    while(len(d2.loc[d2['Track_jetIndex'] == last_tracks]) == 0):
        last_tracks -= 1
        
    if last_tracks > last_jet:
        print("Error: have more tracks than jets! Choose different chunk sizes!")

    # add the track data to the jet list
    d1['track_data'] = pd.np.empty((len(d1.index),0)).tolist()
    
    # iterate over the track list to join jets with the tracks belonging to them
    for irow, row in d2.iterrows():
        # these are the track data of the current track:
        tracks = row[["Track_pt", "Track_eta", "Track_phi", "Track_dxy", "Track_dz", "Track_IP", "Track_IP2D", "Track_length"]].as_matrix()
        jet_index = int(row["Track_jetIndex"])
        if jet_index > last_tracks:
            break
        table_index = d1.loc[d1['Jet_jetIndex'] == jet_index].index[0]

        # append the tracks data to the matching jet in the main table
        d1['track_data'][table_index].append(tracks)

    


